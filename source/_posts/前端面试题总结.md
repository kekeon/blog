---
layout: posts
title: 前端面试题总结
date: 2018-05-08 23:22:48
tags: "javaScript"
---

###  面试题总结

---
###### 1.http 网站请求得整个过程

```
1.域名解析
```

就是将网站名称转变成IP地址：localhost-->127.0.0.1，像什么hosts文件，DNS域名解析等等可以实现这种功能

```
2. 发起TCP的3次握手
```

在客户机和服务器之间建立正常的TCP网络连接时：
		客户机首先发出一个SYN消息，
		服务器使用SYN+ACK应答表示接收到了这个消息，
		最后客户机再以ACK消息响应。
	这样在客户机和服务器之间才能建立起

<!-- more -->
可靠的TCP连接，数据才可以在客户机和服务器之间传递。
```
3. 建立TCP连接后发起http请求
```

发起HTTP请求(HTTP Request)
所谓的HTTP请求，也就是Web客户端向Web服务器发送信息，这个信息由如下三部分组成：
请求头，请求行，请求方式(只在POST请求中存在，因为GET请求并不包含任何实体)

```
4. 服务器端响应http请求
```
浏览器得到html代码

```
5. 浏览器解析html代码，
```
并请求html代码中的资源
了解持久连接
有时候我们获取一个HTML页面，在对浏览器对HTML解析的过程中，如果发现额外的URL需要获取的内容，会再次发起HTTP请求去服务器获取，比如样式文件，图片。许多个HTTP请求，只依靠一个TCP连接就够了，这就是所谓的持久连接。也是所谓的一次HTTP请求完成
```
。
6. 浏览器对页面进行渲染呈现给用户
```

###### 2.webpack glup 得去别，AMD、CMD得区别
sea.js遵循CMD规范.书写方式类似node.js的书写模板代码.依赖的自动加载,配置的简洁清晰.说白了就是懒加载.

require.js遵循AMD规范,CMD和AMD基本相同,最大的区别是就CMD是懒加载,AMD是预加载.

简单来说,就是sea.js属于懒加载,require.js属于预加载.

在这里,顺便扩展一下预加载和懒加载的优缺点

预加载:当第一次访问时将所有的文件加载出来
优点:第一次访问完成以后, 再次访问的速度会很快
缺点:第一次加载页面要等待很久.

懒加载:使用的时候才会加载对应的文件.
优点:第一次访问速度相对快点
缺点:再访问其他新的模块时速度会变慢.

gulp是一个基于流的构建工具，相对其他构件工具来说，更简洁更高效。
webpack是模块化管理的工具，使用webpack可实现模块按需加载，模块预处理，模块打包等功能
https://www.jianshu.com/p/9724c47b406c

webpack 模块化打包原理：
http://blog.csdn.net/u014168594/article/details/77198729）

  1. 一切皆模块：
正如js文件可以是一个“模块（module）”一样，其他的（如css、image或html）文件也可视作模 块。因此，你可以require(‘myJSfile.js’)亦可以require(‘myCSSfile.css’)。这意味着我们可以将事物（业务）分割成更小的易于管理的片段，从而达到重复利用等的目的。
  2. 按需加载：
传统的模块打包工具（module bundlers）最终将所有的模块编译生成一个庞大的bundle.js文件。但是在真实的app里边，“bundle.js”文件可能有10M到15M之大可能会导致应用一直处于加载中状态。因此Webpack使用许多特性来分割代码然后生成多个“bundle”文件，而且异步加载部分代码以实现按需加载。

```
3.require.js  得使用
```


http://www.ruanyifeng.com/blog/2012/11/require_js.html?bsh_bid=230697246


```
4.简单介绍一下webpack，及loader中得作用。
```

  ● css-loader 处理css中路径引用等问题
  ● style-loader 动态把样式写入css
  ● sass-loader scss编译器
  ● less-loader less编译器
  ● postcss-loader scss再处理


```

<!-- more -->
5.webpack 简单配置描述：
```
 https://www.cnblogs.com/pingfan1990/archive/2017/05/21/6886633.html

```
6.当webpack得打包文件过大时怎么进行优化
```

(1)webpack+react的项目打包出来的文件经常动则几百kb甚至上兆，究其原因有：
  ● import css文件的时候，会直接作为模块一并打包到js文件中
  ● 所有js模块 + 依赖都会打包到一个文件
  ● React、ReactDOM文件过大

针对第一种情况，我们可以使用


extract-text-webpack-plugin，但缺点是会产生更长时间的编译，也没有HMR，还会增加额外的HTTP请求。对于css文件不是很大的情况最好还是不要使用该插件。
针对第二种情况，我们可以通过提取公共代码块，这也是比较普遍的做法：

(2).代码压缩 webpack提供的UglifyJS插件由于采用单线程压缩

(3).happypack同时还利用缓存来使得rebuild 更快

(4).alias和noPase resolve.alias是webpack 的一个配置项，它的作用是把用户的一个请求重定向到另一个路径
https://github.com/hawx1993/tech-blog/issues/3


###### 3.开发过程中遇到得兼容性问题，css . js 兼容
html兼容：

```
1.IE
```
 条件注释---IE 的条件注释仅仅针对IE浏览器，对其他浏览器无效


```
2.html
```
 新标签IE不支持--IE8/IE7/IE6支持通过document.createElement方法产生的标签


```
3.css:兼容
```

Ie z-index问题 给父级添加position:relative
css hack原理及常用hack
  ● 原理：利用不同浏览器对CSS的支持和解析结果不一样编写针对特定浏览器样式。

  ● 常见的hack有

     ○ 属性hack
    ○ 选择器hack
    ○ IE条件注释

```
4.js兼容
```

> 1.IE和标准下有哪些兼容性的写法
>
> Var ev = ev || window.event
>
> document.documentElement.clientWidth || document.body.clientWidth
>
> Var target = ev.srcElement||ev.target
>
> 2.标准的事件绑定方法函数为addEventListener，但IE下是attachEvent；
> 3.事件的捕获方式不一致，标准浏览器是由外至内，而IE是由内到外，但是最后的结果是将IE的标准定为标准
>
> 4.window.event获取的。并且获取目标元素的方法也不同，标准浏览器是event.target，而IE下是event.srcElement


###### 4.原型链，原型
  ● 原型：


> 1. JavaScript的所有对象中都包含了一个 [proto] 内部属性，这个属性所对应的就是该对象的原型
>
> 2.JavaScript的函数对象，除了原型 [proto] 之外，还预置了 prototype 属性
>
> 3. 当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 [proto]。

  ● 原型链：

> 1. 当一个对象调用的属性/方法自身不存在时，就会去自己 [proto] 关联的前辈 prototype 对象上去找
>
> 2.如果没找到，就会去该 prototype 原型 [proto] 关联的前辈 prototype 去找。依次类推，直到找到属性/方法或 undefined 为止。从而形成了所谓的“原型链”

  ● 原型特点：

> JavaScript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变

###### 5.rem 得计算方式。
> 设计图750px,iphone 6 得屏幕宽度为375px,  之前设计图为640px
>
>   ● 假设拿到的设计稿和上述网易的一样都是750，Flexible会把设计稿分为10份，可以理解为页面width=10rem，即1rem=75px，所以根font-size（基准值）=75px。
>
> 之后的css换算rem公式为：
>
> px/75=rem,所以100px=100/75=1.33rem,50px=50/75=0.66rem
> 9.闭包怎么理解，及使用场景。

###### 6.简单的理解是函数的嵌套形成闭包，闭包包括函数本身已经它的外部作用域
> 使用闭包可以形成独立的空间，延长变量的生命周期，报存中间状态值
>
>   ● 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域

>   ● 闭包的特性：

>    函数内再嵌套函数\
>    内部函数可以引用外层的参数和变量\
>     参数和变量不会被垃圾回收机制回收

###### 7.css 选择器及权重问题

>   ● id选择器（ # myid）\
>   ● 类选择器（.myclassname）\
>   ● 标签选择器（div, h1, p）\
>   ● 相邻选择器（h1 + p）\
>   ● 子选择器（ul > li）\
>   ● 后代选择器（li a）\
>   ● 通配符选择器（ * ）\
>   ● 属性选择器（a[rel = "external"]）\
>   ● 伪类选择器（a:hover, li:nth-child）\
>   ● 可继承的样式： font-size font-family color, UL LI DL DD DT\
>   ● 不可继承的样式：border padding margin width height\
> CSS优先级算法如何计算？
>   ● 优先级就近原则，同权重情况下样式定义最近者为准\
>   ● 载入样式以最后载入的定位为准\
>   ● 优先级为: !important > id > class > tag \
> important 比内联优先级高

###### 8.同源策略
> 请解释一下 JavaScript 的同源策略\
>   ● 概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape\ Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议\
>   ● 指一段脚本只能读取来自同一来源的窗口和文档的属性\
> 为什么要有同源限制？\
>   ● 我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。\
>   ● 缺点\
>       现在网站的JS都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节


###### 9.跨域的几种方式，jsonp的实现原理

1、 通过jsonp跨域\
2、 document.domain + iframe跨域\
3、 location.hash + iframe
4、 window.name + iframe跨域\
5、 postMessage跨域\
6、 跨域资源共享（CORS）\
7、 nginx代理跨域\
8、 nodejs中间件代理跨域\
9、 WebSocket协议跨域\

jsonp:\
Jsonp并不是一种数据格式，而json是一种数据格式，jsonp是用来解决跨域获取数据的一种解决方案，具体是通过动态创建script标签，然后通过标签的src属性获取js文件中的js脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，本质上使用的并不是ajax技术

document.domain\
目前，很多大型网站都会使用多个子域名，而浏览器的同源策略对于它们来说就有点过于严格了。如，来自www.a.com想要获取document.a.com中的数据。只要基础域名相同，便可以通过修改document.domain为基础域名的方式来进行通信，但是需要注意的是协议和端口也必须相同。

所谓反向代理服务器，它是代理服务器中的一种。客户端直接发送请求给代理服务器，然后代理服务器会根据客户端的请求，从真实的资源服务器中获取资源返回给客户端。所以反向代理就隐藏了真实的服务器。利用这种特性，我们可以通过将其他域名的资源映射成自己的域名来规避开跨域问题

利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。

###### 10.webpack反向代理实现方式
webpack-dev-server配置跨域方案\
如果你项目是用webpack作为前端自动化构建工具的话，那么可以引用webpack-dev-server来进行配置跨域方案。webpack-dev-server是一个小型的nodejs服务器，是基于express框架的，用于实时监听和打包编译静态资源。其中里面有一个属性是proxy，是专门来配置代理请求接口的。

###### 11. mongoDB特性及应用场景，与mysql得不同点
https://yq.aliyun.com/articles/64352?spm=5176.8091938.0.0.oAHbxp\
开源的NoSQL数据库,用于存储非结构化数据,
    SQL中的绝大多数操作有对应的方式来实现,
    采用BSON描述数据类型

用在应用服务器的日志记录，查找起来比文本灵活，导出也很方便。也是给应用练手，从外围系统开始使用MongoDB。 用在一些第三方信息的获取或者抓取，因为MongoDB的schema-less，所有格式灵活，不用为了各种格式不一样的信息专门设计统一的格式，极大的减少开发的工作。
mongodb之前有用过，主要用来存储一些监控数据，No schema 对开发人员来说，真的很方便，增加字段不用改表结构，而且学习成本极低。

###### 12.es6新增特性
现在如果你还不知道es6的新特性的话，可能真的就很难找到工作了

###### 13.promise的用法


```
getJSON('/posts.json').then(function(posts) {
  // ...
}).catch(function(error) {
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log('发生错误！', error);
});
```


Promise.prototype.finally()\
finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。

Promise.all() \
Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。
###### 14.使用实现promise

同时发送多个请求，并且多个请求发送成功之后才算成功，怎么实现？\

```
### (promise.all = [])
const p = Promise.all([p1, p2, p3]);
```

p的状态由p1、p2、p3决定，分成两种情况。\

（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。\

（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。
###### 15.vue 视图组件的使用，父组件与子组件数据的传递方式
父组件数据如何传递给子组件呢？可以通过props属性来实现
子组件通过props来接收数据:

因为vue只允许单向数据传递，这时候我们可以通过触发事件来通知父组件改变数据，从而达到改变子组件数据的目的.\

子组件使用.$emit 向上广播事件

```
this.$emit('upup','hehe');
# 主动触发upup方法，'hehe'为向父组件传递的数据
```


```
<child @upup="change" :msg="msg"></child>
# 监听子组件触发的upup事件,然后调用change方法
```

###### 16.vuex 的的使用
答：vue框架中状态管理。在main.js引入store，注入。\
新建了一个目录store，….. export 。
场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车

###### 17.vuex有哪几种属性？
答：有五种，分别是 State、 Getter、Mutation 、Action、 Module
###### 18.vuex的State特性是？
答：\
一、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放     地，对应于与一般Vue对象里面的data\
二、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新\
三、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中
###### 19.vuex的Getter特性是？
答：
一、getters 可以对State进行计算操作，它就是Store的计算属性\
二、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用\
三、 如果一个状态只在一个组件内使用，是可以不用getters
######  20、vuex的Mutation特性是？
答：
一、Action 类似于 mutation，不同在于：
二、Action 提交的是 mutation，而不是直接变更状态。
三、Action 可以包含任意异步操作
###### 21.Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？
答：
一、如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里.

二、如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用，并包装成promise返回，在调用处用async await处理返回的数据。如果不要复用这个请求，那么直接写在vue文件里很方便。
###### 22.不用Vuex会带来什么问题？
答：\
一、可维护性会下降，你要想修改数据，你得维护三个地方\

二、可读性会下降，因为一个组件里的数据，你根本就看不出来是从哪来的\

三、增加耦合，大量的上传派发，会让耦合性大大的增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背。
###### 23.对模块化的理解
理解模块化开发模式：浏览器端requirejs，seajs；服务器端nodejs；ES6模块化；fis、webpack等前端整体模块化解决方案；grunt、gulp等前端工作流的使用

主要考察你是否有做过比较复杂、庞大的项目，是否具备一定的编程思想。随着前端技术的发展,前端编写的代码量也越来越大，就需要对代码有很好的管理。目前比较好的开发语言就是OOP（面向对象编程）编程语言，例如java语言、C#语言。从JavaScript新的版本来看，要求JavaScript具有封装、继承、多态这样的优点需求越来越明显。这道题属于编程思想上范畴。
###### 24.什么是模块化
所谓的模块化开发就是封装细节，提供使用接口，彼此之间互不影响，每个模块都是实现某一特定的功能。模块化开发的基础就是函数

https://zhuanlan.zhihu.com/p/24355610\

###### 25.页面有哪几种布局方式及实现方法
https://www.cnblogs.com/yanayana/p/7066948.html
###### 26.position的几个属性，及定位的方式

```
● absolute
      ○ 生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。
  ● fixed （老IE不支持）
      ○ 生成绝对定位的元素，相对于浏览器窗口进行定位。
  ● relative
      ○ 生成相对定位的元素，相对于其正常位置进行定位。
  ● static
      ○ 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right - z-index 声明）。
  ● inherit
      ○ 规定从父元素继承 position 属性的值
```

###### 27.浏览器加载页面的整个过程简述, 描述浏览器的渲染过程，DOM树和渲染树的区别？

```
● 浏览器的渲染过程：
      ○ 解析HTML构建 DOM(DOM树)，并行请求 css/image/js
      ○ CSS 文件下载完成，开始构建 CSSOM(CSS树)
      ○ CSSOM 构建结束后，和 DOM 一起生成 Render Tree(渲染树)
      ○ 布局(Layout)：计算出每个节点在屏幕中的位置
      ○ 显示(Painting)：通过显卡把页面画到屏幕上
  ● DOM树 和 渲染树 的区别：
      ○ DOM树与HTML标签一一对应，包括head和隐藏元素
      ○ 渲染树不包括head和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的css属性
```

###### 28.ajax的实现

```

 ● ● 异步传输 + js + xml,
  ● 所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验
  ● 创建XMLHttpRequest对象,也就是创建一个异步调用对象
  ● 建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息
  ● 设置响应HTTP请求状态变化的函数
  ● 发送HTTP请求
  ● 获取异步调用返回的数据
  ● 用JavaScript和DOM实现局部刷新
```

###### 29.函数中this的指向，类中this的指向

```
this 总是指向函数的直接调用者

如果有 new 关键字，this 指向 new 出来的实例对象

在事件中，this指向触发这个事件的对象

IE下 attachEvent 中的this总是指向全局对象Window
```

###### 30.介绍一下浏览器对标签的加载方式

###### 31.介绍事件冒泡

```
事件的三个阶段
  ● 捕获、目标、冒泡
  ● 按照W3C标准的事件：首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段
  ● 事件执行次数（DOM2-addEventListener）：元素上绑定事件的个数
      ○ 注意1：前提是事件被确实触发
      ○ 注意2：事件绑定几次就算几个事件，即使类型和功能完全一样也不会“覆盖”
  ● 事件执行顺序：判断的关键是否目标元素
      ○ 非目标元素：根据W3C的标准执行：捕获->目标元素->冒泡（不依据事件绑定顺序）
      ○ 目标元素：依据事件绑定顺序：先绑定的事件先执行（不依据捕获冒泡标准）
      ○ 最终顺序：父元素捕获->目标元素事件1->目标元素事件2->子元素捕获->子元素冒泡->父元素冒泡
      ○ 注意：子元素事件执行前提 事件确实“落”到子元素布局区域上，而不是简单的具有嵌套关系
  ● 阻止事件默认行为
      ○ W3C: e.preventDefault()
      ○ IE: window.event.returnValue = false
  ● 阻止事件传播
      ○ W3C: e.stopPropagation()
      ○ IE: window.event.cancelBubble = true
```

###### 29.new操作符具体干了什么呢?

```
1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
2、属性和方法被加入到 this 引用的对象中。
3、新创建的对象由 this 所引用，并且最后隐式的返回 this
```

###### 30.浮动会对页面产生什么影响，怎么清除浮动
  ● 浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上


```
列举几种清除浮动的方式？
  ● 添加额外标签，例如 <div style="clear:both"></div>
  ● 使用 br 标签和其自身的 clear 属性，例如 <br clear="all" />
  ● 父元素设置 overflow：hidden; 在IE6中还需要触发 hasLayout，例如zoom：1;
  ● 父元素也设置浮动
  ● 使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout
  ● 清除浮动最佳实践（after伪元素闭合浮动）：

.clearfix:after{
    content: "\200B";
    display: table;
    height: 0;
    clear: both;
  }
  .clearfix{
    *zoom: 1;
  }
```

###### 31.javascript的本地对象，内置对象和宿主对象

```
本地对象为独立于宿主环境的ECMAScript提供的对象，包括Array Object RegExp等可以new实例化的对象
内置对象为Gload，Math 等不可以实例化的(他们也是本地对象，内置对象是本地对象的一个子集)
宿主对象为所有的非本地对象，所有的BOM和DOM对象都是宿主对象，如浏览器自带的document,window 等对象

  ● 数据封装类对象：Object、Array、Boolean、Number、String
  ● 其他对象：Function、Arguments、Math、Date、RegExp、Error
  ● ES6新增对象：Symbol、Map、Set、Promises、Proxy、Reflect
```

###### 32webSocket:
web sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用)
web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。
只有在支持web socket协议的服务器上才能正常工作。
